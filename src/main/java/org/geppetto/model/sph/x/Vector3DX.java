/*******************************************************************************
 * The MIT License (MIT)
 *
 * Copyright (c) 2011 - 2015 OpenWorm.
 * http://openworm.org
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the MIT License
 * which accompanies this distribution, and is available at
 * http://opensource.org/licenses/MIT
 *
 * Contributors:
 *     	OpenWorm - http://openworm.org/people.html
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *******************************************************************************/

//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vhudson-jaxb-ri-2.1-833 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2012.02.19 at 04:43:47 PM CET 
//


package org.geppetto.model.sph.x;

import org.geppetto.model.sph.Vector3D;


public class Vector3DX extends Vector3D{

   
    public Vector3DX(Float x, Float y, Float z) {
		super();
		this.x = x;
		this.y = y;
		this.z = z;
	}
    
	public Vector3DX() {
		super();
	}

	public Vector3DX(Vector3D p)
	{
		this(p.getX(), p.getY(), p.getZ());
		setP(p.getP());
	}

	/** Summation of two vectors 
	 * @param v1
	 * @param v2
	 * @return vector 
	 */
	public static Vector3DX addition(Vector3DX v1, Vector3DX v2){
		return new Vector3DX(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
	}
	
	
	/**Subtraction of two vectors
	 * @param v1
	 * @param v2
	 * @return Vector3D
	 */
	public static Vector3DX subtraction(Vector3DX v1, Vector3DX v2){
		return new Vector3DX(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
	}
	/** Multiplicate vector on scalar
	 * @param v
	 * @param scalar
	 * @return
	 */
	public static Vector3DX mutiplicationOnScalar(Vector3DX v, float scalar){
		return new Vector3DX(v.x * scalar, v.y * scalar, v.z * scalar);
	}
	
	/** Copy coordinates of one vector to current
	 * @param v
	 */
	public void copy(Vector3DX v){
		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
	}
	
	/**Get length of vector
	 * @return 
	 */
	public float length(){
		return (float)Math.sqrt(x*x + y*y + z*z);
	}
	/**
	 * Normalizes this Vector3D that its direction remains the same but its length is 1.
	 */
	public void unitize(){
		float len = this.length();
		if (len == 0)
			return;
		x /=len;
		y /= len;
		z /= len;
	}
	/** Scalar multiplication of two vectors
	 * @param v
	 * @return double value
	 */
	public double scalarMultiplication(Vector3DX v){
		return this.x * v.x + this.y * v.y + this.z * v.z;
	}

}
